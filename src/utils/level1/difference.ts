// **1. 개요**
// 첫 번째 배열(`array`)에서 다른 배열들(`values`)에 포함된 요소들을 제외한 새로운 배열을 반환하는 `difference` 함수를 구현합니다.

// **2. 목적**
// - 두 데이터 그룹 간의 차이점을 찾아내야 할 때 사용합니다.
// - 특정 목록에서 '이미 처리된 항목'이나 '제외 대상 항목'을 한 번에 필터링할 때 유용합니다.

// **3. 요구사항**
// - 첫 번째 인자로 기준이 되는 배열(`array`)을 받습니다.
// - 두 번째 인자부터는 제외할 요소들이 담긴 배열들을 받습니다. (가변 인자 처리)
// - 결과 배열은 기준 배열의 순서를 유지해야 합니다.
// - 대량의 데이터에서도 빠르게 작동하도록 성능을 최적화합니다. (Set 활용)
// - 원본 배열들을 수정하지 않는 불변성을 유지합니다.

// **4. 핵심 로직**
// - 제외할 모든 배열들을 하나로 합친 뒤 `Set`으로 변환하여 조회 속도를 $O(1)$로 최적화합니다.
// - 기준 배열을 `filter`로 순회하며 `Set`에 없는 요소만 남깁니다.

export function difference<T>(array: T[], ...values: T[][]): T[] {
  // 1. 방어 코드: 입력이 배열이 아니면 안전하게 빈 배열 반환
  if (!array || !Array.isArray(array)) {
    return [] as T[];
  }

  // 2. 미세 최적화: 제외할 배열들이 아예 없다면 굳이 Set을 만들지 않고 원본 복사본 반환
  if (values.length === 0) {
    return [...array];
  }

  // 3. 성능 최적화: 모든 제외 배열을 하나로 합쳐서 Set 생성
  // values.flat(1)은 T[]를 반환하므로 Set<T>가 정확히 추론됩니다.
  const excludeSet = new Set(values.flat(1));

  // 4. 차집합 계산: 기준 배열 순서를 유지하며 Set에 없는 것만 추출
  // filter의 결과는 자동으로 T[]이므로 안전하지만, 명시적으로 타입을 보장합니다.
  return array.filter((item) => !excludeSet.has(item)) as T[];
}