# 🚀 TS-Lodash Type Definition Mastery

오픈소스 라이브러리인 **Lodash**의 핵심 유틸리티 함수들을 TypeScript로 재설계하며, 고수준 타입 시스템의 활용법과 실무적인 트러블슈팅 경험을 기록한 프로젝트입니다.

---

## 📌 주요 설계 의도 및 구현 기능

### Level 1: 배열 조작 및 타입 안전성

- **`head<T>` (기초 제네릭)**: 배열의 정체성을 추적하고 `undefined` 가능성을 타입(`T | undefined`)으로 명시하여 런타임 안정성 확보.
- **`compact<T>` (타입 가드)**: `Type Predicates (item is T)`를 활용하여 `filter` 이후에도 남아있는 `null/undefined` 유니온 타입을 완벽히 제거.

### Level 2: 객체 변형 및 키 매핑

- **`omit<T, K>` (Exclude & Pick)**: 특정 속성을 제거한 새로운 객체 생성. 객체 불변성을 위해 스프레드 문법(`...`)을 활용한 얕은 복사 적용.
- **`pick<T, K>` (Mapped Types)**: `[P in K]` 문법을 직접 구현하여 필요한 속성만 선택적으로 추출 (예정).

### Level 3~5: 고수준 타입 설계 (로드맵)

- **`groupBy` (오버로딩)**: 함수 오버로딩을 통해 콜백 방식과 키 선택 방식 모두에 최적화된 추론 제공.
- **`debounce` (Intersection)**: 원본 함수의 시그니처를 보존하면서 추가 메서드(`.cancel()`)를 결합한 하이브리드 타입 구현.
- **`get` (Recursive Template Literal)**: 점(`.`)으로 구분된 문자열 경로를 파싱하여 깊은 속성 타입을 재귀적으로 추론.

---

## 🔍 주요 트러블슈팅 경험 (Troubleshooting)

### 1. 필수 속성(Required) 삭제 시 컴파일 에러

- **문제**: `omit` 구현 중 `delete` 연산자 사용 시 필수 속성 삭제 금지 에러 발생.
- **해결**: 내부 로직에서 `as any`를 사용하여 일시적으로 타입 검사를 우회하되, 외부 반환 타입은 `Omit<T, K>`로 엄격하게 정의하여 '내부의 유연함'과 '외부의 안전성'을 동시에 확보함.

### 2. 빈 배열(`[]`)의 타입 추론 실패

- **문제**: 초기값이 없는 배열 선언 시 `never[]`로 추론되어 함수 호출 에러 발생.
- **해결**: `const arr: number[] = []`와 같이 명시적인 **타입 주석(Type Annotation)**을 추가하여 해결.

### 3. 런타임과 컴파일 타임의 간극 (`is not a function`)

- **문제**: `.d.ts` 선언과 실제 구현체의 부재로 인한 실행 에러.
- **해결**: 타입 설계와 구현 로직을 하나의 `.ts` 파일로 통합하고, `ts-node` 환경에서 경로 별칭 인식을 위해 `tsconfig-paths` 설정을 최적화함.

---

## 💡 Key Lessons & Deep Dive

### Q. 왜 객체를 복사(`{...obj}`)해서 써야 하나요?

자바스크립트의 객체는 **참조(Reference)**로 전달됩니다. 원본을 직접 수정하면 외부 코드에 영향을 주는 **부작용(Side Effect)**이 발생하므로, 불변성을 유지하여 함수의 예측 가능성을 높여야 합니다.

### Q. `as any`는 언제 사용해야 할까요?

타입 시스템이 로직 구현을 지나치게 방해하는 특수한 경우(예: `delete`)에 한해 제한적으로 사용합니다. 핵심은 **캡슐화**입니다. 함수 내부의 '위험한 코드'가 외부 인터페이스의 '안전한 타입'을 망치지 않도록 설계하는 것이 중요합니다.

### Q. `Pick`과 `Omit`의 내부 원리는?

`Omit`은 독립적인 마법이 아니라 `Pick`과 `Exclude`의 조립입니다.
`type Omit<T, K> = Pick<T, Exclude<keyof T, K>>`
이 구조를 이해함으로써 '타입 전용 계산기'인 유틸리티 타입의 정체를 파악했습니다.

---

## 📈 프로젝트 회고

이번 프로젝트를 통해 TypeScript의 제네릭이 단순히 타입을 열어두는 것이 아니라, 데이터의 흐름을 끝까지 추적하는 강력한 도구임을 깨달았습니다. 라이브러리 제작자의 관점에서 타입 안정성과 사용 편의성 사이의 균형점을 깊이 있게 고민하며 성장하고 있습니다.
