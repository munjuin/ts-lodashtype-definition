# 🚀 TS-Lodash Type Definition Mastery

오픈소스 라이브러리인 **Lodash**의 핵심 유틸리티 함수들을 TypeScript로 재설계하며, 고수준 타입 시스템의 활용법과 실무적인 트러블슈팅 경험을 기록한 프로젝트입니다.

---

## 📌 주요 설계 의도 및 구현 기능

### ✅ Level 1: 기초 제네릭 및 배열 조작

- **`head<T>` & `last<T>`**: 배열의 첫/마지막 요소 추출. 빈 배열 시 `undefined` 반환을 타입으로 강제하여 안정성 확보.
- **`tail<T>`**: 첫 요소를 제외한 나머지 배열 반환 (`T[]`). 빈 배열 시에도 빈 배열을 반환하는 안전한 슬라이싱 로직.
- **`nth<T>`**: n번째 요소 추출. 음수 인덱스 지원 로직을 통해 뒤에서부터의 접근성 구현.
- **`compact<T>`**: Falsy 값 제거 및 **타입 정화**. `item is T` 문법을 사용하여 필터링 후 배열의 타입을 깨끗하게 좁힘(Narrowing).

### ✅ Level 2: 중급 객체 변형 및 키 매핑

- **`omit<T, K>`**: 특정 키 제외. `Exclude`와 `Pick`의 조합 원리를 학습하고, 내부 구현 시 `as any`를 활용한 캡슐화 전략 적용.
- **`pick<T, K>`**: 특정 키 선택. `Mapped Types ({ [P in K]: T[P] })`를 직접 구현하며 내장 유틸리티 타입의 내부 동작 이해.

### 🚀 Advanced: 고수준 타입 설계

- **`groupBy` (함수 오버로딩)**: 콜백 함수 또는 객체의 키(문자열)를 인자로 전달할 수 있는 유연성 제공. `K extends keyof T`를 통한 안정적 키 접근.
- **`debounce` (Intersection Types)**: 원본 함수의 매개변수 정보를 보존하면서, 인터섹션(`&`)을 통해 `.cancel()`, `.flush()` 메서드를 결합한 하이브리드 타입 구현.
- **`get` (Recursive Template Literal)**: `'user.profile.name'`과 같은 점(`.`) 구분자 경로를 파싱하여 깊은 속성 타입을 재귀적으로 추론(`infer` 활용).

---

## 💡 Technical Deep Dive (핵심 기술 분석)

### 1. `compact<T>`와 타입 술어 (Type Predicates)

단순한 `filter`는 데이터는 제거하지만 배열의 타입 정의(Union)는 수정하지 못합니다.

- **해결**: `(item): item is T => Boolean(item)` 형식을 사용하여, 조건 통과 시 해당 요소가 확실히 `T`임을 컴파일러에게 확신시킵니다.

### 2. 객체 불변성 (Immutability)

객체는 참조(Reference)로 전달되므로 원본 수정 시 부작용(Side Effect)이 발생합니다. 스프레드 문법(`{ ...obj }`)을 사용해 원본을 보호하는 '순수 함수' 지향적 설계를 준수합니다.

### 3. `as any`의 전략적 사용 (캡슐화)

`delete` 연산자처럼 TypeScript가 기본적으로 금지하는 동작을 수행할 때는 내부에서 `as any`로 유연하게 처리하되, 외부 인터페이스는 엄격한 타입을 유지하여 사용자의 안전을 지키는 **캡슐화**가 중요함을 학습했습니다.

---

## 🔍 주요 트러블슈팅 경험

### 1. 필수 속성(Required) 삭제 시 컴파일 에러

- **문제**: `omit` 구현 중 필수 속성 삭제 시 발생하는 정적 분석 에러.
- **해결**: 내부 구현 로직에서만 타입 검사를 우회하고, 반환 타입은 유틸리티 타입을 통해 정교하게 정의하여 해결.

### 2. 빈 배열(`[]`)의 `never[]` 추론 이슈

- **문제**: 초기값이 없는 배열 선언 시 발생하는 타입 불일치.
- **해결**: 명시적인 **타입 주석(Type Annotation)**을 추가하여 타입 추론의 한계를 극복.

### 3. 런타임과 컴파일 타임의 간극 해결 (`is not a function`)

- **문제**: `.d.ts`에 선언만 존재하고 실제 로직이 없어 발생한 실행 에러.
- **해결**: 타입 설계와 구현을 통합한 `.ts` 모듈 구조로 변경하고, `tsconfig-paths` 설정을 통해 런타임 경로 별칭 매핑 최적화.

---

## 📈 프로젝트 회고

이번 프로젝트를 통해 TypeScript의 제네릭이 단순히 타입을 열어두는 것이 아니라, **데이터의 흐름을 끝까지 추적하는 강력한 도구**임을 깨달았습니다. 특히 복잡한 유틸리티 함수를 직접 설계해보며, 라이브러리 제작자가 고려해야 할 타입 안정성과 사용 편의성 사이의 균형점을 깊이 있게 고민해 볼 수 있었습니다.
